terminals {
	keyword semicolon [phantom] /;/;
	keyword arrow [phantom] /-->/;
	keyword lbracket [phantom] /[/;
	keyword rbracket [phantom] /]/;
	keyword lbrace [phantom] /{/;
	keyword rbrace [phantom] /}/;
 	keyword phantom /phantom/;
	keyword ignore /ignore/;
	pattern clearspace [ignore] /\s+/;
	pattern identifier /[a-zA-Z][a-zA-Z0-9]*/;
	keyword rulesToken [phantom] /rules/;
	keyword keyword /keyword/;
	keyword pattern /pattern/;
	keyword terminalsToken [phantom] /terminals/;
	pattern patternToken /(?<!/)/(?!/).*(?<!/)/(?!/)/;
	keyword semanticsToken [phantom] /semantics/;
	keyword requires [phantom] /requires/;
	keyword as [phantom] /as/;
	keyword lparen [phantom] /(/;
	keyword rparen [phantom] /)/;

} rules {
	s --> terminals rules semantics;
	endOfOptions [phantom] --> epsilon;
	endOfOptions --> phantom endOfOptions;
	endOfOptions --> ignore endOfOptions;
	options --> epsilon;
	options --> lbracket endOfOptions rbracket;
	terminal --> epsilon;
	terminal --> keyword identifier options patternToken
			semicolon terminal;
	terminal --> pattern identifier options patternToken
			semicolon terminal;
	terminals [phantom] --> terminalsToken lbrace terminal rbrace;
	endOfRule [phantom] --> identifier endOfRule;
	endOfRule --> epsilon;
	rule --> identifier options arrow endOfRule semicolon rule;
	rule --> epsilon;
	rules [phantom] --> rulesToken lbrace rule rbrace;

	semantics --> semanticsToken lbrace semantic rbrace;
	semantic --> epsilon;
	semantic --> term requires condition as error;
	termlist --> epsilon

	term --> identifier lparen term rparen;
}

